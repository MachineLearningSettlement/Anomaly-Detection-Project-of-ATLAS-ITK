1. Description de l'approche à appliquer

Dans le cadre de ce projet, nous avons appliqué une multitude d'approches :

1.1 Ajustement des hyperparamètres (voir mémoire section 3.3.1)

Le script à utiliser est PatchCore_detection.py, dans lequel nous devons personnaliser nos hyperparamètres.

1.2 Réduction du bruit (voir mémoire section 3.3.2)

Les scripts à utiliser sont adapteimages.py, pour débruiter les patchs et réduire l’effet de granularité des surfaces de cuivre, avant de lancer PatchCore_detection.py sur ce nouveau dataset 
avec des hyperparamètres personnalisés.

1.3 Redimensionnement des patchs, filtration des pixels noirs et exclusion des bordures (voir mémoire section 3.3.3)

Les scripts à utiliser sont image_cleaning.py (situé dans le dossier Dataset_Construction), qui divise les images originales en patchs de 128x128 (paramètre à adapter dans le script). Ensuite, 
nous supprimons les patchs d’entraînement contenant plus de 90 % de pixels noirs (paramètre à adapter) avec no_black_pad.py. Pour l’exclusion des bordures, nous convertissons les résultats 
de détection en masques binaires avec convertoutputtomask.py, puis nous convertissons les patchs de test en échelle binaire avec tresholdtiles.py avant de les éroder avec erodingtiles.py.
L’intersection entre les patchs binaires érodés et les résultats de détection binaires permet d’obtenir une meilleure qualité de détection d’anomalies avec moins de faux positifs.
Ces détections, encore en échelle binaire, peuvent ensuite être projetées sur les patchs originaux de test sous forme de masques rouges à l’aide de reconstructtilefrommask.py. Notez bien qu'on 
peut utiliser recalculate_metrics.py pour évaluer les métriques de ségmentation et de classification entre les masques obtenus après l'exclusion des bordures et les masques de ground_truth

>>> L’approche 1.3 est celle qui donne les meilleurs résultats et est considérée comme le pipeline algorithmique le plus optimal à adopter dans le cadre du projet.


-----------------------------------------------------------------------------------------

2. Description du contenu : 

PatchCore_detection.py : code source permettant d’exécuter le modèle PatchCore.

adapteimages.py : utilisé si l’on souhaite appliquer un débruitage afin de réduire le bruit de granularité présent sur les plaques de cuivre (approche d’amélioration).

check.py : vérifie que le nombre d’images dans le dossier test est identique à celui du ground_truth.

convertoutputtomask.py : convertit les masques de détection des patchs de test générés par PatchCore en noir et blanc (échelle binaire).

erodingtiles.py : applique une érosion sur les patchs de test.

no_black_pad.py : filtre les patchs d’entraînement en supprimant ceux contenant un pourcentage de pixels noirs supérieur ou égal à un seuil défini (entre 50 % et 90 %).

output_mask_intersection.py : conserve uniquement, en échelle binaire, les zones d’intersection entre les patchs érodés (issus de erodingtiles.py) et les masques de détection (issus de convertoutputtomask.py).

reconstructtilefrommask.py : réajuste les résultats de détection issus de output_mask_intersection.py sur les patchs de test originaux.

tresholdtiles.py : convertit les patchs de test en noir et blanc (échelle binaire).

recalculate_metrics.py : Recalcule les métriques Pixel F1Score et Image F1Score.
